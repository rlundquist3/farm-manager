{"version":3,"sources":["meteor://ðŸ’»app/packages/anti_gagarin/meteor/settings.js","meteor://ðŸ’»app/packages/anti_gagarin/meteor/backdoor.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/anti_gagarin.js","sourcesContent":["\nif (!Meteor.settings.gagarin && process.env.GAGARIN_SETTINGS) {\n  try {\n    Meteor.settings.gagarin = JSON.parse(process.env.GAGARIN_SETTINGS);\n  } catch (err) {\n    console.warn('invalid Gagarin settings\\n', err);\n  }\n}\n\nvar settings = Meteor.settings.gagarin;\n\nGagarin = {};\n\nGagarin.isActive = !!settings;\n\nif (Gagarin.isActive) {\n  Gagarin.settings = settings;\n}\n\nMeteor.startup(function () {\n\n  if (!Gagarin.isActive) {\n    return;\n  }\n\n  maybeCreateUser(settings);\n});\n\nMeteor.startup(function () {\n\n  if (!Gagarin.isActive) {\n    return;\n  }\n\n  maybeCreateUser(settings);\n});\n\nfunction maybeCreateUser (settings) {\n\n  var userId = null;\n\n  if (!Package['accounts-password']) {\n    return;\n  }\n\n  if (!settings.username || !settings.password) {\n    return;\n  }\n\n  Meteor.users.remove({ username: settings.username });\n\n  userId = Accounts.createUser({\n    username : settings.username,\n    password : settings.password,\n  });\n\n  Meteor.users.update({_id: userId}, { $set: {\n    gagarin : true\n  }});\n\n}\n\n\n","\nvar vm = Npm.require('vm');\nvar Fiber = Npm.require('fibers');\nvar Future = Npm.require('fibers/future');\n\nvar chai, plugins = {};\n\nif (Gagarin.isActive) {\n\n  chai = Npm.require('chai');\n\n  chai.should();\n  chai.use(Npm.require('chai-things'));\n\n  plugins.chai   = chai;\n  plugins.Fiber  = Fiber;\n  plugins.expect = chai.expect;\n  plugins.assert = chai.assert;\n  plugins.either = function either (first) {\n    return { or: function (second) {\n        return function (arg1, arg2) { return arg1 ? first(arg1) : second(arg2) };\n    }};\n  };\n\n  // TODO: also protect these methods with some authentication (user/password/token?)\n  //       note that required data my be provided with GAGARIN_SETTINGS\n\n  Meteor.methods({\n\n    '/gagarin/execute': function (context, closure, code, args) {\n      \"use strict\";\n\n      args = args || [];\n\n      check(code, String);\n      check(args, Array);\n      check(closure, Object);\n      check(context, Object);\n\n      return compile(code, closure).apply({}, values(closure, function (userFunc, getClosure) {\n        try {\n          return { value : userFunc.apply(context, args), context: context, closure : getClosure() };\n        } catch (err) {\n          return { error: err.message, context: context, closure: getClosure() };\n        }\n      }));\n\n    },\n\n    '/gagarin/promise': function (context, closure, code, args) {\n      \"use strict\";\n\n      args = args || [];\n\n      check(code, String);\n      check(args, Array);\n      check(closure, Object);\n      check(context, Object);\n\n      var future = new Future();\n\n      var ready = function (feedback) {\n        if (!feedback.context) {\n          feedback.context = context;\n        }\n        if (feedback.error && typeof feedback.error === 'object') {\n          feedback.error = feedback.error.message;\n        }\n        future['return'](feedback);\n      };\n\n      // either return immediately (e.g. on error) or future.wait()\n      return compile(code, closure).apply({}, values(closure, function (userFunc, getClosure) {\n        // reject\n        args.unshift(_.once(function (error) { setTimeout(function () { ready({ error: error, closure: getClosure() }); }); }));\n\n        // resolve\n        args.unshift(_.once(function (value) { setTimeout(function () { ready({ value: value, closure: getClosure() }); }); }));\n\n        try {\n          userFunc.apply(context, args);\n        } catch (err) {\n          return { error: err.message, context: context, closure: getClosure() };\n        }\n\n      })) || future.wait();\n    },\n\n    '/gagarin/wait': function (context, closure, timeout, message, code, args) {\n      \"use strict\";\n\n      args = args || [];\n\n      check(timeout, Number);\n      check(message, String);\n      check(code, String);\n      check(args, Array);\n      check(closure, Object);\n      check(context, Object);\n\n      var future  = new Future();\n      var handle1 = null;\n      var handle2 = null;\n\n      function ready(feedback) {\n        //-------------------------\n        clearTimeout(handle1);\n        clearTimeout(handle2);\n        if (!feedback.context) {\n          feedback.context = context;\n        }\n        if (feedback.error && typeof feedback.error === 'object') {\n          feedback.error = feedback.error.message;\n        }\n        future['return'](feedback);\n      }\n\n      // either return immediately (e.g. on error) or future.wait()\n      return compile(code, closure).apply({}, values(closure, function (userFunc, getClosure) {\n        handle2 = setTimeout(function () {\n          ready({ closure: getClosure(), error: 'I have been waiting for ' + timeout + ' ms ' + message + ', but it did not happen.' });\n        }, timeout);\n        (function test() {\n          var value;\n          try {\n            value = userFunc.apply(context, args);\n            if (value) {\n              return ready({ closure: getClosure(), value: value });\n            }\n          } catch (error) {\n            return ready({ closure: getClosure(), error: error });\n          }            \n          handle1 = setTimeout(Meteor.bindEnvironment(test), 50); // repeat after 1/20 sec.          \n        }());\n      })) || future.wait();\n    },\n\n  });\n\n  function norifyWeAreReady () {\n    console.log('ÐŸÐ¾ÐµÑ…Ð°Ð»Ð¸!'); // Let's ride! (Gagarin, during the Vostok 1 launch)\n  }\n\n  if (WebApp.onListening) {\n    WebApp.onListening(norifyWeAreReady);\n\n  } else {\n    Meteor.startup(norifyWeAreReady);\n  }\n\n}\n\n/**\n * Provide plugins the the local context.\n *\n * @param {(string|string[])} code\n * @returns {string[]}\n */\nfunction providePlugins(code) {\n  var chunks = [];\n  if (typeof code === 'string') {\n    code = code.split('\\n');\n  }\n  chunks.push(\"function (\" + Object.keys(plugins).join(', ') + \") {\");\n  chunks.push(\"  return \" + code[0]);\n\n  code.forEach(function (line, index) {\n    if (index === 0) return; // omit the first line\n    chunks.push(\"  \" + line);\n  });\n  chunks.push(\"}\");\n  return chunks;\n}\n\n/**\n * Make sure that the only local variables visible inside the code,\n * are those from the closure object.\n *\n * @param {(string|string[])} code\n * @param {Object} closure\n * @returns {string[]}\n */\nfunction isolateScope(code, closure) {\n  if (typeof code === 'string') {\n    code = code.split('\\n');\n  }\n  var keys = Object.keys(closure).map(function (key) {\n    return stringify(key) + \": \" + key;\n  });\n  var chunks = [];\n\n  chunks.push(\n    \"function (\" + Object.keys(closure).join(', ') + \") {\",\n    \"  'use strict';\",\n    \"  return (function (userFunc, getClosure, action) {\",\n    \"    try {\",\n    \"      return action(userFunc, getClosure);\",\n    \"    } catch (err) {\",\n    // this should never happen ...\n    \"      return { error: err.message, closure: getClosure() };\",\n    \"    }\",\n    \"  })(\"\n  );\n\n  // the code provided by the user goes here\n  align(code).forEach(function (line) {\n    chunks.push(\"    \" + line);\n  });\n  chunks[chunks.length-1] += ',';\n\n  chunks.push(\n    // the function returning current state of the closure\n    \"    function () {\",\n    \"      return { \" + keys.join(', ') + \" };\",\n    \"    },\",\n\n    // the custom action\n    \"    arguments[arguments.length-1]\",\n    \"  );\",\n    \"}\"\n  );\n\n  return chunks;\n}\n\n/**\n * Fixes the source code indentation.\n *\n * @param {(string|string[])} code\n * @returns {string[]}\n */\nfunction align(code) {\n  if (typeof code === 'string') {\n    code = code.split('\\n');\n  }\n  var match = code[code.length-1].match(/^(\\s+)\\}/);\n  var regex = null;\n  if (match && code[0].match(/^function/)) {\n    regex = new RegExp(\"^\" + match[1]);\n    return code.map(function (line) {\n      return line.replace(regex, \"\");\n    });\n  }\n  return code;\n}\n\n/**\n * Creates a function from the provided source code and closure object.\n *\n * @param {(string|string[])} code\n * @param {Object} closure\n * @returns {string[]}\n */\nfunction compile(code, closure) {\n  code = providePlugins(isolateScope(code, closure)).join('\\n');\n  try {\n    return vm.runInThisContext('(' + code + ')').apply({}, values(plugins));\n  } catch (err) {\n    throw new Meteor.Error(400, err);\n  }\n}\n\n/**\n * Returns all values of the object, sorted\n * alphabetically by corresponding keys.\n *\n * @param {Object}\n * @returns {Array}\n */\nfunction values(object) {\n  \"use strict\";\n\n  var values = Object.keys(object).map(function (key) {\n    return object[key];\n  });\n  if (arguments.length > 1) {\n    values.push.apply(values, Array.prototype.slice.call(arguments, 1));\n  }\n  return values;\n}\n\n/**\n * A thin wrapper around JSON.stringify:\n *\n *  - `undefined` gets evaluated to \"undefined\"\n *  - a function gets evaluated to source code\n *\n * @param {Object} value\n * @returns {string}\n */\nfunction stringify(value) {\n  \"use strict\";\n\n  if (typeof value === 'function') {\n    return value.toString();\n  }\n  return value !== undefined ? JSON.stringify(value) : \"undefined\";\n}\n\n"]}